* Costs
  :PROPERTIES:
  :EXPORT_FILE_NAME: ../Materials/Project4/example_costs.ipynb
  :END:
** Preface

   There are a few modules you may need to install:
 #+begin_src jupyter-python
#!pip install -r requirements.txt
 #+end_src

We import critical objects from =example_nutrition.py=, avoiding the need to do so in this notebook.  These are for Uganda:
#+begin_src jupyter-python
from example_nutrition import r as uga
from example_nutrition import rdi, nutrient_demand
#+end_src


** Ceteris Paribus

    We begin by setting up some benchmarks for prices and budgets, so
    the things we don't want to change we can hold fixed.
  #+begin_src jupyter-python
from example_nutrition import pbar, my_prices
  #+end_src

** Simple Policy Experiments: Changing Budget

 Consider two policies:  First, changing income so that some proportion
 of the population achieves nutritional adequacy.  Here choose quantile
 we're interested in (e.g., a quantile of 0.5 is the median; a quantile
 of 0.25 is the household at the 25th percentage point of the distribution).

 #+begin_src jupyter-python

# Predicted budgets (sum of all expenditures for each household)
xbar = uga.predicted_expenditures().groupby(['i','t']).sum()

# Drop households with /no/ predicted expenditures
xbar = xbar.where(xbar>0)

# A quantile of 0.5 is the median.  Play with quantile value, or just assign.
x0 = xbar.quantile(0.5) # Budget (median household)

# Range of budgets to explore
X = np.linspace(x0/10,x0*5,50)
#+end_src


** Simple Policy Experiments: Changing Prices

If price of a good increases/decreases, what's the cost to the
household?  Ask a related question: If a price $p_1$ increases, how
much /income/ do we need to give to the household to make it just as
well off as it was at the old prices?

Summarize this as the  /compensating variation/ associated with the
price change.

[[./compensating_variation.png]]

Compensating Variation can also be measured as the (change in the)
area under the *Hicksian* (or *compensated*) demand curve:

[[./compensating_variation_newexpenditure.png]].


*** Marshallian vs. Hicksian Demand Curves

Let's look at Marshallian & Hicksian demands---one way of thinking
about the Hicksian (compensated) curves is that they  eliminate the
income effect associated with changing prices.

 #+begin_src jupyter-python
import matplotlib.pyplot as plt

#my_i = 'bread'  # Interesting Ugandan staple

# Utility of median household, given prices
U0 = r.indirect_utility(x0,p)  

plt.plot([r.demands(x0,my_prices(p0,i=my_i))[my_i] for p0 in P],P)
plt.plot([r.demands(U0,my_prices(p0,i=my_i),type="Hicksian")[my_i] for p0 in P],P)
plt.ylabel('Price')
plt.xlabel(my_i)
#plt.axhline(p.sel(i=my_i).values)
plt.legend(("Marshallian","Hicksian"))
 #+end_src


*** Welfare measures
 #+begin_src jupyter-python :results silent
def compensating_variation(U0,p0,p1):
    x0 = r.expenditure(U0,p0)
    x1 = r.expenditure(U0,p1)

    return x1-x0

def revenue(U0,p0,p1,type='Marshallian'):
    """(Un)Compensated revenue from taxes changing vector of prices from p0 to p1.

    Note that this is only for *demand* side (i.e., if supply perfectly elastic).
    """
    
    dp = p1 - p0 # Change in prices

    c = r.demands(U0,p1,type=type)

    dp,c = dp.align(c,join='inner')

    return dp.T@c


def deadweight_loss(U0,p0,p1):
    """
    Deadweight loss of tax/subsidy scheme creating wedge in prices from p0 to p1.

    Note that this is only for *demand* side (i.e., if supply perfectly elastic).
    """
    cv = compensating_variation(U0,p0,p1)

    return cv - revenue(U0,p0,p1,type='Hicksian') 
    
    
def compensated_nutrient_demand(U,p,z=None):
    c = r.demands(U,p,z=z,type='Hicksian')
    fct0,c0 = fct.align(c,axis=0,join='inner')
    N = fct0.T@c0

    return N

def compensated_nutrient_adequacy_ratio(U,p):
    return (compensated_nutrient_demand(U,p)/hh_rdi.T).squeeze()

 #+end_src

*** Price Changes, Revenue, and Compensating Variation

Examine effects of price changes on revenue (if price change due to a
tax or subsidy) and compensating variation.

 #+begin_src jupyter-python
fig, ax1 = plt.subplots()

ax1.plot(P,[compensating_variation(U0,phat,my_prices(p0,i=my_i)) for p0 in P])
ax1.set_xlabel("Price of %s" % my_i)
ax1.set_ylabel("Compensating Variation")

ax1.plot(P,[revenue(U0,phat,my_prices(p0,i=my_i),type='Hicksian') for p0 in P],'k')
ax1.legend(('Compensating Variation','Revenue'))
ax1.axhline(0)
ax1.axvline(phat.loc[my_i])

 #+end_src

*** Deadweight Loss

Differences between revenue and compensating variation is deadweight-loss:
 #+begin_src jupyter-python
fig, ax1 = plt.subplots()

ax1.plot(P,[deadweight_loss(U0,phat,my_prices(p0,i=my_i)) for p0 in P])
ax1.set_xlabel("Price of %s" % my_i)
ax1.set_ylabel("Deadweight Loss")
 #+end_src





