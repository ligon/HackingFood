* Costs
  :PROPERTIES:
  :EXPORT_FILE_NAME: ../Materials/Project4/example_costs.ipynb
  :END:
** Preface

   There are a few modules you may need to install:
 #+begin_src ipython
#!pip install -r requirements.txt
 #+end_src

   Some countries we have data for:
#+begin_src ipython
URL = {'Uganda':'https://docs.google.com/spreadsheets/d/1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ/',
       'Tanzania':'https://docs.google.com/spreadsheets/d/1Tknc2F8K6SaA7j0R7J_NE8yJBTsCPPw77_Bfc04MY40/',
       'Indian ICRISAT':'https://docs.google.com/spreadsheets/d/13Ig5hZif-NSHtgkKRp_cEgKXk0lOsdUB2BAD6O_FnRo'}

DAYS_PER_PERIOD = {'Uganda':7,'Tanzania':7,'Indian ICRISAT':365.25} # Number of days of expenditure recall
#+end_src

Exploit fact that we've already estimated demand systems for a bunch
of different countries.  Choose one:

 #+begin_src ipython
import cfe

COUNTRY = 'Uganda'

# May need to unzip?
#!gunzip Uganda_small.ds.gz

r = cfe.from_dataset("%s_small.ds" % COUNTRY,engine='netcdf4')

 #+end_src


** Ceteris Paribus

    We begin by setting up some benchmarks for prices and budgets, so
    the things we don't want to change we can hold fixed.
  #+begin_src ipython
import numpy as np

### First year, first market, and some good.  Change if you wish! ###
my_t = r.coords['t'].data.flatten()[0] # Period
my_m = r.coords['m'].data.flatten()[0] # Market
my_i = 'bread' # r.coords['i'].data.flatten()[0] # Good
#####################################################################

p = r.prices.sel(u='Kilogram (kg)',t=my_t,m=my_m,drop=True)
phat = p.to_dataframe('i').dropna().squeeze()

ref_price = r.prices.sel(u='Kilogram (kg)',i=my_i,t=my_t,m=my_m)
P = np.linspace(ref_price/10,ref_price*5,50)

def my_prices(p0,p=phat,i=my_i):
    """
    Set price of good i to p0, holding remaining prices fixed at values in p.
    """
    p = p.copy()
    p.loc[i] = p0
    return p.squeeze()

phat
  #+end_src

** Simple Policy Experiments: Changing Budget

 Consider two policies:  First, changing income so that some proportion
 of the population achieves nutritional adequacy.  Here choose quantile
 we're interested in (e.g., a quantile of 0.5 is the median; a quantile
 of 0.25 is the household at the 25th percentage point of the distribution).

 #+begin_src ipython

# A quantile of 0.5 is the median.  Play with quantile value, or just assign.
xbar = r.get_predicted_expenditures().sel(t=my_t,m=my_m).sum('i')

# Drop households with /no/ predicted expenditures
xbar = xbar.where(xbar>0)

x0 = xbar.quantile(0.5,'j') # Budget (median household)
#x0 = 50

# Range of budgets to explore
X = np.linspace(x0/10,x0*5,50)
#+end_src


** Simple Policy Experiments: Changing Prices

If price of a good increases/decreases, what's the cost to the
household?  Ask a related question: If a price $p_1$ increases, how
much /income/ do we need to give to the household to make it just as
well off as it was at the old prices?

Summarize this as the  /compensating variation/ associated with the
price change.

[[./compensating_variation.png]]

Compensating Variation can also be measured as the (change in the)
area under the *Hicksian* (or *compensated*) demand curve:

[[./compensating_variation_newexpenditure.png]].


*** Marshallian vs. Hicksian Demand Curves

Let's look at Marshallian & Hicksian demands---one way of thinking
about the Hicksian (compensated) curves is that they  eliminate the
income effect associated with changing prices.

 #+begin_src ipython
import matplotlib.pyplot as plt

#my_i = 'bread'  # Interesting Ugandan staple

U0 = r.indirect_utility(x0,p)

plt.plot([r.demands(x0,my_prices(p0,i=my_i))[my_i] for p0 in P],P)
plt.plot([r.demands(U0,my_prices(p0,i=my_i),type="Hicksian")[my_i] for p0 in P],P)
plt.ylabel('Price')
plt.xlabel(my_i)
#plt.axhline(p.sel(i=my_i).values)
plt.legend(("Marshallian","Hicksian"))
 #+end_src


*** Welfare measures
 #+begin_src ipython :results silent
def compensating_variation(U0,p0,p1):
    x0 = r.expenditure(U0,p0)
    x1 = r.expenditure(U0,p1)

    return x1-x0

def revenue(U0,p0,p1,type='Marshallian'):
    """(Un)Compensated revenue from taxes changing vector of prices from p0 to p1.

    Note that this is only for *demand* side (i.e., if supply perfectly elastic).
    """
    
    dp = p1 - p0 # Change in prices

    c = r.demands(U0,p1,type=type)

    dp,c = dp.align(c,join='inner')

    return dp.T@c


def deadweight_loss(U0,p0,p1):
    """
    Deadweight loss of tax/subsidy scheme creating wedge in prices from p0 to p1.

    Note that this is only for *demand* side (i.e., if supply perfectly elastic).
    """
    cv = compensating_variation(U0,p0,p1)

    return cv - revenue(U0,p0,p1,type='Hicksian') 
    
    
def compensated_nutrient_demand(U,p,z=None):
    c = r.demands(U,p,z=z,type='Hicksian')
    fct0,c0 = fct.align(c,axis=0,join='inner')
    N = fct0.T@c0

    return N

def compensated_nutrient_adequacy_ratio(U,p):
    return (compensated_nutrient_demand(U,p)/hh_rdi.T).squeeze()

 #+end_src

*** Price Changes, Revenue, and Compensating Variation
Examine effects of price changes on revenue (if price change due to a
tax or subsidy) and compensating variation.

 #+begin_src ipython
fig, ax1 = plt.subplots()

ax1.plot(P,[compensating_variation(U0,phat,my_prices(p0,i=my_i)) for p0 in P])
ax1.set_xlabel("Price of %s" % my_i)
ax1.set_ylabel("Compensating Variation")

ax1.plot(P,[revenue(U0,phat,my_prices(p0,i=my_i),type='Hicksian') for p0 in P],'k')
ax1.legend(('Compensating Variation','Revenue'))
ax1.axhline(0)
ax1.axvline(phat.loc[my_i])

 #+end_src

*** Deadweight Loss

Differences between revenue and compensating variation is deadweight-loss:
 #+begin_src ipython
fig, ax1 = plt.subplots()

ax1.plot(P,[deadweight_loss(U0,phat,my_prices(p0,i=my_i)) for p0 in P])
ax1.set_xlabel("Price of %s" % my_i)
ax1.set_ylabel("Deadweight Loss")
 #+end_src





